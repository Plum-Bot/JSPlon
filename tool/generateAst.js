#!/usr/bin/env node

const fs = require('fs')
const path = require('path')
const outputDir = process.argv[2]

if (!outputDir) {
    console.error('usage: node generateAst.tool.js <output directory>')
    process.exit(1)
}

const indent = '    '

defineAst(outputDir, 'Expr', {
    Assign:       'Token name, Expr value',
    Binary:       'Expr left, Token operator, Expr right',
    Call:         'Expr callee, Token paren, Expr[] args',
    Get:          'Expr object, Token name',
    Grouping:     'Expr expression',
    Literal:      'Object value',
    Logical:      'Expr left, Token operator, Expr right',
    Postfix:      'Expr left, Token operator',
    Set:          'Expr object, Token name, Expr value',
    SubscriptGet: 'Expr object, Token name, Token bracket',
    Ternary:      'Expr left, Token leftOperator, Expr center, Token rightOperator, Expr right',
    This:         'Token keyword',
    Unary:        'Token operator, Expr right',
    Variable:     'Token name'
})

defineAst(outputDir, 'Stmt', {
    Block:        'Stmt[] statements',
    Class:        'Token name, Function[] methods',
    Const:        'Token name, Expr initializer',
    Expression:   'Expr expression',
    Function:     'Token name, Token[] params, Stmt[] body, boolean isStatic, boolean isGetter',
    If:           'Expr condition, Stmt thenBranch, Stmt[] elseIfBranches, Stmt elseBranch',
    Print:        'Expr expression',
    Repeat:       'Expr number, Expr step, Stmt body',
    Return:       'Token keyword, Expr value',
    Var:          'Token name, Expr initializer',
    While:        'Expr condition, Stmt body, boolean isFor'
})

function defineAst(outputDir, baseName, types) {
    const outputPath = path.resolve(outputDir, baseName + '.js')
    const writer = fs.createWriteStream(outputPath)

    writer.write(`// DO NOT EDIT THIS FILE DIRECTLY! It is generated by ${path.basename(__filename)} \n\n`);

    let imports = [...new Set(Array.from(Object.values(types)).map(s => s.split(", ")[0]).filter(s => s[0].toUpperCase() == s[0] && s != "Object").map(s => s.split(" ")[0].replace("[]", "")))].filter(s => s != baseName);

    console.log(imports);

    imports.forEach(import_ => {
        // writer.write(`import ${import_} from "./${import_}";\n`);
    })

    writer.write(`\nclass ${baseName} {\n`)
    writer.write(`${indent}accept(visitor) {}\n\n`)
    writer.write(`${indent}toString() {\n`)
    writer.write(`${indent}${indent}return "AST Node Superclass: ${baseName}"\n`)
    writer.write(`${indent}}\n`)
    writer.write(`}\n\n`)

    const classNames = Object.keys(types)
    classNames.forEach(className => {
        defineType(writer, baseName, className, types[className])
        writer.write('\n')
    })

    const allExports = classNames.map(className =>
        `${indent}${className}`
    ).join(`,\n`)

    writer.write(`module.exports = {\n`)
    writer.write(`${indent}${baseName},\n`);
    writer.write(allExports)
    writer.write('\n}\n')

    writer.end()
}

function defineType(writer, baseName, className, fieldList) {
    writer.write(`class ${className} extends ${baseName} {\n`)

    const fields = fieldList.split(', ')
    const fieldNames = fields.map(field =>
        field.split(' ')[1]
    );

    fieldNames.forEach(fieldName => {
        writer.write(`${indent}${fieldName};\n`);
    });
    writer.write(`\n${indent}constructor(${fieldNames.join(', ')}) {\n`)
    writer.write(`${indent}${indent}super()\n`)
    fieldNames.forEach(fieldName => {
        writer.write(`${indent}${indent}this.${fieldName.split(":")[0]} = ${fieldName.split(":")[0]};\n`)
    })
    writer.write(`${indent}}\n\n`)

    writer.write(`${indent}accept(visitor) {\n`)
    writer.write(`${indent}${indent}return visitor.visit${className}${baseName}(this);\n`)
    writer.write(`${indent}}\n\n`)

    writer.write(`${indent}toString() {\n`)
    writer.write(`${indent}${indent}return "AST Node: ${baseName} ${className}";\n`)
    writer.write(`${indent}}\n`)

    writer.write(`}\n`)
}